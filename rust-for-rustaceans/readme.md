# 第一章 基础

当你深入到 Rust 的更高级的角落时，重要的是你要确保你对基础知识有一个坚实的理解。在 Rust 中，就像任何编程语言一样，当你开始以更复杂的方式使用该语言时，各种关键字和概念的确切含义变得非常重要。在本章中，我们将浏览 Rust 的许多基元，并试图更清楚地定义它们的含义，它们是如何工作的，以及为什么它们是这样的。具体来说，我们将看看变量和值有什么不同，它们在内存中是如何表示的，以及一个程序有哪些不同的内存区域。然后，我们将讨论一些所有权、借用和寿命的微妙之处，在你继续阅读本书之前，你需要掌握这些知识。

如果你愿意，你可以从头到尾地阅读这一章，也可以把它作为参考，来复习那些你觉得不太确定的概念。我建议你只有在对本章的内容感到完全满意时才继续阅读，因为对这些基元如何工作的误解会很快妨碍你理解更高级的主题，或者导致你错误地使用它们。

## 谈谈内存

不是所有的内存都是平等的。在大多数编程环境中，你的程序可以访问栈（stack）、堆（heap）、寄存器（register）、文本段（text segment）、内存映射的寄存器（memory-mapped register）、内存映射的文件（memory-mapped file），也许还有非易失性 RAM（Nonvolatile RAM）。在特定情况下，你选择使用哪一个，对你能在那里存储什么，它能保持多长时间，以及你用什么机制来访问它都有影响。这些内存区域的具体细节因平台而异，超出了本书的范围，但有些内存区域对你如何推理 Rust 代码非常重要，因此值得在此介绍。

### 内存术语

在我们深入研究内存区域之前，你首先需要了解值、变量和指针之间的区别。Rust 中的值是一个类型和该类型的值域的一个元素的组合。一个值可以使用其类型的表示法变成一串字节，但就其本身而言，你可以认为一个值更像是你这个程序员的意思。例如，`u8` 类型中的数字 `6` 是数学整数 `6` 的一个实例，它在内存中的表示是字节 `0x06`。同样，字符串 "Hello world" 是所有字符串域中的一个值，其表示方法是 UTF-8 编码。一个值的意义与这些字节存储的位置无关。

一个值被存储在一个地方，这是 Rust 的术语，意思是 "一个可以容纳一个值的位置"。这个位置可以在栈中，也可以在堆上，或者在其他一些位置。最常见的存储值的地方是一个变量，它是栈上的一个命名值槽。

指针是一个持有内存区域地址的数值，所以指针指向一个地方。指针可以被解引用，以访问存储在它所指向的内存位置的值。我们可以在一个以上的变量中存储同一个指针，因此有多个变量间接地指向内存中的同一个位置，从而指向同一个底层值。

考虑清单 1-1 中的代码，它说明了这三个要素。

```rust
let x = 42;
let y = 43;
let var1 = &x;
let mut var2 = &x;
var2 = &y; // (1)

// 清单 1-1：值、变量和指针
```

这里，有四个不同的值。`42`（一个`i32`），`43`（一个`i32`），`x` 的地址（一个指针），以及 `y` 的地址（一个指针）。还有四个变量：`x`、`y`、`var1` 和 `var2`。后两个变量都持有指针类型的值，因为引用是指针。虽然 `var1` 和 `var2` 最初存储的是同一个值，但它们分别存储该值的独立副本；当我们改变 `var2` (1) 中存储的值时，`var1` 中的值不会改变。特别是，`=` 运算符将右侧表达式的值存储在左侧命名的地方。

变量、值和指针之间的区别变得很重要的一个有趣的例子是在一个语句中，比如说：

```rust
let string = "Hello world";
```

尽管我们给变量 `string` 分配了一个字符串值，但该变量的实际值是一个指向字符串值 "Hello world "中第一个字符的指针，而不是字符串值本身。在这一点上，你可能会说："但是等一下，那么字符串的值是在哪里存储的？指针指向哪里？" 如果是这样的话，你的眼光就很敏锐了--我们一会儿就会说到这一点。

### 深入了解变量

我前面给出的变量定义很宽泛，本身不太可能有什么用。当你遇到更复杂的代码时，你将需要一个更准确的心智模型来帮助你推理出程序的真正作用。我们可以利用许多这样的模型。详细描述它们会占用好几章的篇幅，也超出了本书的范围，但广义上讲，它们可以分为两类：高层模型（High-level）和低层模型（low-level）。高层模型在思考生存期和借用层面的代码时很有用，而低层模型在推理不安全代码和原始指针时很有用。下面两节描述的变量模型对于本书的大部分材料来说已经足够了。

#### 高层模型

在高级模型中，我们不认为变量是存放字节的地方。当你给一个变量赋值的时候，这个值就被这个变量命名了。当一个变量后来被访问时，你可以想象从该变量的前一次访问到新的访问画一条线，这在两次访问之间建立了一种依赖关系。如果一个变量中的值被移动了，就不能再从它那里画线了。

**High-Level Model**

In the high-level model, we don’t think of variables as places that hold bytes. Instead, we think of them just as names given to values as they are instantiated, moved, and used throughout a program. When you assign a value to a variable, that value is from then on named by that variable. When a variable is later accessed, you can imagine drawing a line from the previous access of that variable to the new access, which establishes a dependency relation ship between the two accesses. If the value in a variable is moved, no lines  can be drawn from it anymore.

在这个模型中，一个变量只有在它持有一个合法的值时才存在；你不能从一个值未被初始化或已被移动的变量上画线，所以实际上它不存在。使用这个模型，你的整个程序由许多这样的依赖线组成，通常称为流，每个流都追踪一个值的特定实例的生存期。当有分支时，流可以分叉和合并，每一个分叉都追踪该值的一个不同的生存期。编译器可以检查在程序的任何给定点，所有可以相互平行存在的流都是兼容的。例如，不能有两个并行的流对一个值进行可变的访问。也不能有一个流借用一个值，而没有一个流拥有该值。清单 1-2 显示了这两种情况的例子。

```rust
let mut x;
// 这是非法的，没有地方可以获取流
// assert_eq!(x, 42);
x = 42;     // (1)
// 这是好的，可以从上面分配的值中画出一个流程。
let y = &x; // (2)
// 这就建立了第二个来自 x 的、可变的流。
x = 43;     // (3)
// 这样就继续从 y 那里获得流，而 y 又从 x 那里获得流。 
// 但这条流与对 x 的分配相冲突！
assert_eq!(*y, 42); // (4)

// 清单 1-2：借用检查器会发现的非法流
```

首先，在 `x` 被初始化之前，我们不能使用它，因为我们没有地方可以绘制流。只有当我们给 `x` 赋值时，我们才能从它那里提取流。这段代码有两个流：一个从 `(1)` 到 `(3)` 的独占（`&mut`）流，一个从 `(1)` 到 `(2)` 到 `(4)` 的共享（`&`）流。 借阅检查器检查每个流的每个顶点，并检查是否有其他不兼容的流同时存在。在这个例子中，当借用检查器检查 `(3)` 处的独占流时，它看到了终止于 `(4)` 处的共享流。由于你不能同时对一个值进行独占和共享使用，借用检查器（正确地）拒绝了该代码。请注意，如果没有 `(4)`，这段代码会编译得很好。共享流将在 `(2)` 处终止，而当独占流在 `(3)` 处被检查时，就不会有冲突的流存在。

如果一个新的变量与之前的变量同名，它们仍然被认为是不同的变量。这被称为 "遮蔽"--后一个变量 "遮蔽"了前一个同名的变量。这两个变量共存，尽管随后的代码不再有办法命名先前的变量。这个模型与编译器，特别是借用检查器，对你的程序的推理大致吻合，并且实际上在编译器的内部使用，以产生高效代码。

#### 底层模型

变量命名了可能持有或不持有合法数值的内存位置。你可以把一个变量看作是一个 "值槽"。当你给它赋值时，槽被填满，它的旧值（如果它有一个的话）被丢弃和替换。当你访问它时，编译器会检查该槽是否为空，因为这意味着该变量未被初始化或其值已被移动。一个变量的指针指的是该变量的后备内存，可以被解引用以获得其值。例如，在语句 `let x: usize` 中，变量 `x` 是堆栈上一个内存区域的名称，该区域有空间容纳一个 `usize` 大小的值，尽管它没有一个明确的值（其槽是空的）。如果你给这个变量赋值，比如 `x = 6`，那么这个内存区域就会容纳代表值 `6` 的比特。这个模型与 C 和 C++以及其他许多低级语言所使用的内存模型相匹配，当你需要对内存进行明确的推理时，这个模型很有用。

> 注意：在这个例子中，我们忽略了 CPU 寄存器，并将其视为一种优化。在现实中，如果一个变量不需要内存地址，编译器可能会使用一个寄存器来支持该变量，而不是一个内存区域。

你可能会发现其中一个比另一个更适合你之前的模型，但我建议你试着仔细理解这两个模型。它们都是同样有效的，而且都是简化的，就像任何有用的心智模型一样。如果您能够从这两个角度考虑一段代码，您就会发现处理复杂的代码段并理解它们为什么要或不按照预期进行编译和工作要容易得多。

### 内存区域

现在你已经掌握了我们对内存的称呼，我们需要谈谈内存到底是什么。内存有许多不同的区域，也许令人惊讶的是，并不是所有的区域都存储在你的计算机的 DRAM 中。你使用哪一部分内存，对你如何编写代码有很大影响。就编写 Rust 代码而言，三个最重要的区域是栈、堆和静态内存。

#### 栈

栈是一段内存，程序使用它作为函数调用的临时空间。每次调用一个函数时，都会在栈的顶部分配一个称为帧的连续内存块。靠近栈底部的是主函数的帧，当函数调用其他函数时，额外的帧被推送到栈中。函数的帧包含该函数中的所有变量，以及该函数接受的任何参数。当函数返回时，它的栈帧被回收。

构成函数局部变量值的字节不会立即被清除，但访问它们是不安全的，因为它们可能被随后的函数调用覆盖，而该函数调用的帧与回收的帧重叠。即使它们没有被覆盖，它们也可能包含非法使用的值，例如在函数返回时被移动的值。

栈帧，以及它们最终消失的关键事实，与 Rust 中的生存期概念密切相关。任何存储在栈上的帧中的变量在该帧消失后都不能被访问，所以任何对它的引用都必须有一个最长与帧生存期一样长的生存期。

#### 堆

堆是一个内存池，它没有绑定到程序的当前调用栈。堆内存中的值会一直存在，直到它们被显式地回收。当您希望一个值存在超过当前函数帧的生存期时，这是很有用的。如果该值是函数的返回值，则调用函数可以在其栈上留下一些空间，以便被调用函数在返回之前将该值写入其中。但是，如果你想，比如说，发送这个值到一个不同的线程，而当前线程可能根本不共享栈帧，你可以把它存储在堆上。

堆允许您显式地分配连续的内存段。当你这样做的时候，你会得到一个指向该内存段开始的指针。这个内存段是为你保留的，直到你以后释放它；这个过程通常被称为释放，以 C 标准库中相应函数的名称命名。由于函数返回时 heap 的分配不会消失，所以您可以在一个位置为一个值分配内存，将指向它的指针传递给另一个线程，并让该线程安全地继续操作该值。或者，换句话说，当你堆分配内存时，结果指针有一个不受约束的生存期——它的生存期是你的程序保持它存活的时间。

在 Rust 中与堆交互的主要机制是 `Box` 类型。当您写入 `Box::new(value)` 时，该值被放在堆上，而返回给您的 (`Box<T>`) 是一个指向堆上该值的指针。当 `Box` 最终被丢弃时，内存将被释放。

如果你忘记删除堆内存，它将永远存在，你的应用程序最终会吃掉你机器上的所有内存。这被称为泄漏内存，通常是你想要避免的。然而，在有些情况下，你会明确地想要泄漏内存。例如，假设你有一个只读的配置，整个程序都应该能够访问。你可以在堆上分配这个配置，然后用 `Box::leak` 显式地泄露它，以获得一个 "静态引用"。

#### 静态内存

静态内存实际上是一个包揽一切的术语，指的是程序被编译成的文件中几个密切相关的区域。当程序执行时，这些区域会自动加载到程序的内存中。静态内存中的值在程序执行的整个过程中都是有效的。你的程序的静态内存包含程序的二进制代码，它通常被映射为只读。当您的程序执行时，它将遍历文本段指令中的二进制代码，并在调用函数时跳转。静态内存还保存了使用`static` 关键字声明的变量的内存，以及代码中的某些常量值，比如字符串。

特殊的生存期 `'static`，它的名称来自静态内存区域，标志着一个引用在静态内存存在的时间内是有效的，也就是直到程序关闭。因为静态变量的内存是在程序启动时分配的，所以对静态内存中变量的引用定义为 `'static`，因为在程序关闭之前它不会被释放。反之则不然，可能会有不指向静态内存的 `'static` 引用，但这个名字仍然是合适的：一旦你创建了一个具有静态寿命的引用，就程序的其他部分而言，它所指向的东西可能就在静态内存中，因为它可以被使用多长时间，你的程序就会使用多长时间。

在使用 Rust 时，您将更经常地遇到 `'static`生存期，而不是真正的静态内存（例如，通过 `static` 关键字）。这是因为 `static`经常出现在类型参数的 trait 限定中。像 `T: 'static` 这样的绑定表示类型参数 `T` 能够存活，我们就保留它多久，包括程序的剩余执行时间。本质上，这个限定要求 `T` 是拥有（owned）的和自给自足（self-sufficient）的，要么它不借用其他（非静态）值，要么它借用的任何东西也是 `'static`，因此会一直保留到程序结束。`'static` 作为限定的一个很好的例子是 `std::thread::spawn`函数，它创建了一个新的线程，它要求传递给它的闭包是 `'static` 。由于新线程的生存期可能比当前线程长，因此新线程不能引用存储在旧线程堆栈上的任何内容。新线程只能引用在其整个生存期内（可能是在程序的剩余时间内）存在的值。

> 注意：您可能想知道 `const` 与 `static` 有何不同。 `const` 关键字将下面的项声明为常量。可以在编译时完全计算常数项，任何引用它们的代码都将在编译期间替换为常数的计算值。常量没有与之关联的内存或其他存储（它不是一个位置）。您可以将常量看作是特定值的一个方便名称。

## 所有权

Rust 的内存模型的核心思想是，所有值都有一个所有者，也就是说，只有一个位置（通常是一个作用域）负责最终回收每个值。这是通过借用检查器强制执行的。如果值被移动，例如将其赋值给一个新变量、将其推入一个向量或将其放在堆上，则值的所有权将从旧位置移动到新位置。在这一点上，您不能再通过来自原始所有者的变量访问值，即使从技术上来说，组成值的位仍然存在。相反，您必须通过引用其新位置的变量来访问被移动的值。

有些类型是反叛者，不遵守这条规则。如果一个值的类型实现了特殊的 `Copy` 特性，即使它被重新分配到一个新的内存位置，它也不会被认为已经移动了。相反，该值被复制，新旧位置仍然可访问。从本质上说，在移动的目的地构造了另一个相同值的相同实例。Rust 中大多数基本类型（如整数和浮点类型）都是 `Copy` 类型。要成为 Copy 类型，必须能够简单地通过复制其比特来复制该类型的值。这排除了所有包含非 `Copy` 类型的类型，以及在值被删除时它必须释放的拥有资源的任何类型。

要知道为什么，请考虑一下如果像 `Box` 这样的类型被复制会发生什么。如果我们执行 `box2 = box1`，那么 `box1` 和 `box2` 都会认为他们拥有为 `box` 分配的堆内存，当他们超出范围时，他们都会试图释放它。释放两次内存可能会产生灾难性的后果。

当一个值的所有者不再使用它时，该所有者有责任通过删除该值来对该值进行任何必要的清理。在 Rust 中，当保存值的变量不再在作用域中时，删除将自动发生。类型通常递归地删除它们所包含的值，因此删除复杂类型的变量可能会导致许多值被删除。由于 Rust 的离散所有权要求，我们不能意外地多次丢弃相同的价值。保存对另一个值的引用的变量并不拥有另一个值，因此当变量删除时，该值不会被删除。

清单 1-3 中的代码给出了围绕所有权、移动和复制语义以及放弃的规则的快速总结。

```
let x1 = 42;
let y1 = Box::new(84);
{ // 开始一个新的作用域
let z = (x1, y1); // (1)
// z 离开作用域，并被析构；
// 它一次析构了 x1 和 y1 中的值
} // (2)
// x1 的值是 Copy 语义， 所以它不会移动给 z
let x2 = x1; // (3)
// y1 的值不是 Copy 语义，所以它会移动给 z
// let y2 = y1; // (4)

// 清单 1-3: 移动和复制语义
```

我们从两个值开始，数字 `42` 和包含数字 `84` 的 `Box（一个堆分配的值）。前者是复制，而后者不是。当我们将` `x1` 和 `y1` 放入元组 `z1` `时，x1` 被复制到 `z` 中，而 `y1` 被移动到 `z` 中。此时，`x1` 继续可访问，并可以再次使用 (3) 。另一方面，一旦 `y1` 的值被移动到 (4)，它就变得不可访问，任何访问它的尝试都将导致编译器错误。当 `z` 超出范围 (2) 时，它所包含的元组值将被删除，这将依次删除从 `x1` 复制的值和从 `y1` 移动的值。当 `y1` 中的 `Box` 被丢弃时，它还释放用于存储 `y1` 值的堆内存。

> 析构顺序
>
> 当值超出作用域时，Rust 会自动丢弃它们，比如清单 1-3 中内部作用域的 x1 和 y1。丢弃顺序的规则相当简单：变量（包括函数参数）按相反的顺序丢弃，嵌套值按源代码的顺序丢弃。
>
> 这听起来可能很奇怪，为什么会有这样的差异？不过，如果我们仔细观察，就会发现它有很大的意义。假设你写了一个函数，声明了一个字符串，然后将该字符串的引用插入到一个新的哈希表中。当函数返回时，哈希表必须先被删除；如果字符串先被删除，那么哈希表就会持有一个无效的引用 一般来说，后来的变量可能包含对早期值的引用，而由于 Rust 的生存期规则，反之则不能发生。出于这个原因，Rust 以相反的顺序丢弃变量。
>
> 现在，我们可以对嵌套的值有同样的行为，比如元组、数组或结构中的值，但这可能会让用户感到惊讶。如果你构建了一个包含两个值的数组，如果数组的最后一个元素先被丢弃，那就显得很奇怪。这同样适用于元组和结构，最直观的行为是第一个元组元素或字段先被丢弃，然后是第二个，以此类推。与变量不同的是，在这种情况下没有必要颠倒丢弃顺序，因为 Rust（目前）不允许在单个值中进行自我引用。所以，Rust 采用了直观的选项。

## 借用和生存期

Rust 允许一个值的所有者通过引用将该值借给其他人，而不放弃所有权。引用是一个指针，它有一个额外的契约，规定了它们的使用方式，比如引用是否提供了对被引用值的唯一访问，或者被引用值是否也可以有其他引用指向它。

### 共享引用

顾名思义，是一个可以被共享的指针。对于相同的值，可以存在任意数量的其他引用，并且每个共享引用都是 `Copy`，因此您可以轻松地创建更多的共享引用。共享引用背后的值不是可变的；您不能修改或重新分配共享引用指向的值，也不能将共享引用强制转换为可变引用。

Rust 编译器允许假设共享引用指向的值在引用存在期间不会改变。例如，如果 Rust 编译器看到共享引用后面的值在函数中被多次读取，那么它有权只读取一次并重用该值。更具体地说，清单 1-4 中的断言应该永远不会失败。

```
fn cache(input: &i32, sum: &mut i32) {
    *sum = *input + *input;
    assert_eq!(*sum, 2 * *input);
} 

// 清单 1-4: Rust 假设共享引用是不可变的。
```

编译器是否选择应用给定的优化或多或少是无关的。编译器的启发式会随着时间的推移而改变，所以你通常想要根据编译器被允许做什么来编写代码，而不是根据它在特定的情况下在特定的时间点实际做了什么。

### 可变引用

共享引用的替代方案是可变引用：&mut T。对于可变引用，Rust 编译器又被允许充分利用引用所带来的契约：编译器假设没有其他线程访问目标值，无论是通过共享引用还是可变引用。换句话说，它假定可变引用是独占的。这使得一些有趣的优化成为可能，这些优化在其他语言中是不容易实现的。以清单 1-5 中的代码为例。

```
fn noalias(input: &i32, output: &mut i32) {
    if *input == 1 {
        *output = 2; // (1)
    } if *input != 1 {  // (2)
        *output = 3;
    }
}

// 清单 1-5:  Rust 假设可变借用是独占的
```

在 Rust 中，编译器可以假设输入和输出不指向同一内存。因此，(1) 处输出的重新分配不能影响 (2) 处的检查，整个函数可以被编译为一个单一的 `if-else` 块。如果编译器不能依赖排他性可变性契约，那么这种优化就会失效，因为在 `noalias(&x, &mut x)`这样的情况下，(1) 的输入可能导致 (3) 的输出。

一个可改变的引用只允许你改变该引用所指向的内存位置。你是否可以改变直接引用之外的值，取决于位于两者之间的类型所提供的方法。用一个例子可能更容易理解，所以考虑清单 1-6。

```
let x = 42;
let mut y = &x; // y &i32 类型
let z = &mut y; // z 是 &mut &i32 类型

// 清单 2-6: 可变性只适用于直接引用的内存
```

在这个例子中，你能够通过使指针 `y` 引用不同的变量来改变它的值（也就是不同的指针），但你不能改变被指向的值（也就是 `x`的值）。同样地，你可以通过 `z` 来改变 `y` 的指针值，但你不能改变 `z` 本身，使其持有不同的引用。

拥有一个值和拥有一个对它的可变引用之间的主要区别是，当不再需要这个值时，所有者要负责丢弃这个值。除此之外，你可以通过一个可改变的引用做任何事情，如果你拥有这个值的话，有一个注意事项：如果你把这个值移到可改变的引用后面，那么你必须在它的位置上留下另一个值。如果你不这样做，所有者仍然会认为它需要放弃这个值，但是没有任何值可以让它放弃。

清单 1-7 给出了将值移动到可变引用后面的方法示例。

```
fn replace_with_84(s: &mut Box<i32>) {
    // 这是不可能的，因为 *s 会变成空值 :
    // let was = *s; // (1)
    // 但是这可以：
    let was = std::mem::take(s); // (2)
    // 这也可以：
    *s = was; // (3)
    // 可以在 &mut 后面交换值：
    let mut r = Box::new(84);
    std::mem::swap(s, &mut r); // (4)
    assert_ne!(*r, 84);
}

let mut s = Box::new(42);
replace_with_84(&mut s);
// (5)

// 清单 2-7：可变性仅适用于直接引用的内存。
```

你不能简单地将值移出 `1`，因为调用者仍然认为他们拥有该值，并会在 `5` 处再次释放它，导致双重释放。如果你只是想留下一些有效的值，`std::mem::take` (2) 是一个不错的选择。它相当于 `std::mem::replace(&mut value, Default::default())`；它将值从可变引用后面移出，但为该类型留下一个新的、默认的值。默认值是一个单独的、自有的值，所以当作用域在 `5` 处结束时，调用者可以安全地析构它。

另外，如果你不需要引用后面的旧值，你可以用一个你已经拥有的值覆盖它 (3)，让调用者以后再丢弃这个值。当你这样做的时候，原来在可变引用后面的值会被立即丢弃。

最后，如果你有两个可变的引用，你可以在不拥有任何一个引用的情况下交换它们的值 (4)，因为两个引用最后都会有一个合法拥有的值，供它们的主人最终释放。

### 内部可变性

有些类型提供内部可变性，这意味着它们允许您通过共享引用改变值。这些类型通常依赖于额外的机制（如原子 CPU 指令）或不变量来提供安全的可变性，而不依赖于独占引用的语义。它们通常分为两类：一类允许您通过共享引用获得可变引用，另一类允许您替换仅给定共享引用的值。

第一类包括 `Mutex` 和 `RefCell` 这样的类型，它们包含安全机制，以确保对于它们提供的任何可变引用，同一时刻只能存在一个可变引用（没有共享引用）。在本质上，这些类型（以及类似的类型）都依赖于一个名为 `UnsafeCell` 的类型，该类型的名称会立即让您犹豫是否使用它。我们将在第 9 章中更详细地介绍 `UnsafeCell`，但现在你应该知道，这是通过共享引用进行变异的唯一正确方法。

提供内部可变性的其他类型是那些不给出内部值的可变引用，而只是提供适当操作该值的方法的类型。`std::sync::atomic` 和 `std::cell::cell` 类型中的原子整数就属于这一类。您不能直接获取此类类型后面的 `usize` 或 `i32` 的引用，但是可以在给定的时间点读取和替换它的值。

> 注意：标准库中的 Cell 类型是通过不变量实现安全内部可变性的一个有趣的例子。它不能跨线程共享，并且永远不会给出对 Cell 中包含的值的引用。相反，这些方法要么完全替换该值，要么返回所包含值的副本。由于内部值不能存在任何引用，所以移动它总是可以的。而且，由于 Cell 不能在线程之间共享，因此即使通过共享引用发生突变，内部值也永远不会并发地发生突变。

### 生存期

如果您正在阅读这本书，您可能已经熟悉了生存期的概念，这可能是由于编译器对生存期规则违反的反复通知。这种程度的理解将为您编写的大多数 Rust 代码提供良好的服务，但是随着我们深入研究 Rust 更复杂的部分，您将需要一个更严格的心智模型来工作。

较新的 Rust 开发人员经常被教导将生存期与作用域相对应：生存期开始于对某个变量的引用，结束于该变量被移动或超出作用域。这通常是正确的，通常也是有用的，但实际情况要复杂一些。生存期实际上是某个引用必须有效的代码区域的名称。虽然生存期经常与作用域相一致，但这并不是必须的，正如我们将在本节后面看到的那样。

#### 生存期和借用检查器

Rust 生存期的核心是借用检查器。每当一个具有某种生存期的引用被使用时，借用检查器就会检查 `'a` 是否仍然活着。它通过追踪路径回到 `'a` 开始的地方--引用被取走的地方--从使用点开始，并检查该路径上是否有冲突的使用。这可以确保引用仍然指向一个可以安全访问的值。这类似于我们在本章前面讨论的高级 "数据流 " 心智模型；编译器检查我们正在访问的引用的流不会与任何其他并行流相冲突。

清单 1-8 显示了一个简单的代码例子，其中有对 `x` 的引用的生存期注释。

```
let mut x = Box::new(42);
let r = &x;   // (1)            // 'a
if rand() > 0.5 {
    *x = 84;  // (2)
} else {
    println!("{}", r); // (3)   // 'a
}
// (4)

// 清单 1-8：生存期不需要是连续的
```

当我们对 `x` 进行引用时，生存期从 (1) 开始。在第一个分支 (2) 中，我们立即尝试修改 `x`，将其值更改为 `84`，这需要一个 `&mut x`。借用检查器取出 `x` 的可变引用并立即检查其使用情况。它发现在获取引用和使用引用之间没有冲突，所以它接受代码。这是个令人惊讶的消息如果你习惯于思考生存期范围，因为 `r` 仍在范围 (2)（超出范围在 (4))。但是借用检查器足够聪明，它意识到如果这个分支被选中，以后就不会再使用 `r`，因此 `x` 在这里被可变访问是没有问题的。或者，换一种说法，在 (1) 处创建的生存期不会扩展到这个分支：没有来自 `r` 超过 (2) 的流，因此没有冲突流。然后借用检查器在打印语句 (3) 中找到了对 `r` 的使用。它沿着路径返回到 (1)，并发现没有冲突的用途 ((2) 不在该路径上），所以它也接受这种用途。

如果我们在清单 1-8 中在 `4` 处添加 `r` 的另一个使用，代码将不再编译。生存期 `'a` 将从 (1) 一直持续到 (4) (`r` 的最后一次使用），当借用检查器检查 `r` 的新的使用时，它会在 (2) 处发现一个冲突的使用。

生存期可以变得相当复杂。在清单 1-9 中，你可以看到一个有漏洞的生存期的例子，它在开始和最终结束的地方间歇性地失效了

```
let mut x = Box::new(42);
let mut z = &x;        // (1)   // 'a
for i in 0..100 {
    println!("{}", z); // (2)   // 'a
    x = Box::new(i);   // (3)
    z = &x;            // (4)   // 'a
} 
println!("{}", z);              // 'a

// 清单 1-9: 生存期有漏洞
```

当我们对 `x` 进行引用时，生存期从 (1) 开始。然后我们在 (3) 处离开 `x`，这将结束生存期 `'a`，因为它不再有效。借用检查器通过考虑 `'a` 结束于 (2)，这使得 `x` 和 (3) 之间没有冲突流”来接受这一移动。然后，通过更新 `z` (4) 中的引用，重新启动生存期。无论代码现在是循环回到 `2` 还是继续到最后的 `println!` 语句，这两个用途现在都有一个有效的值可以流出来，而且没有冲突的流，所以借用检查器接受了这段代码。

同样，这与我们之前讨论的内存的数据流模型完全一致。当 `x` 被移动时，`z` 停止存在。当我们稍后重新分配 `z` 时，我们创建了一个全新的变量，这个变量只从这一点开始存在。碰巧的是，这个新变量也被命名为 `z`。

> 注意：借用检查器是，而且必须是，保守的。如果它不确定一个借用是否有效，它就会拒绝它，因为允许一个无效的借用的后果可能是灾难性的。借用检查器越来越聪明，但有时它也需要帮助来理解为什么一个借用是合法的。这就是为什么我们有不安全的 Rust 的部分原因。

#### 泛型生存期

偶尔你需要在自己的类型中存储引用，这些引用需要有一个生存期，这样当它们被用于该类型的各种方法时，借用检查器可以检查它们的有效性。如果你想让你的类型上的一个方法返回一个比对 `self` 的引用更久远的引用，这一点尤其重要。

Rust 允许您在一个或多个生存期内使类型定义泛型，就像它允许您使类型泛型一样。Steve Klabnik 和 Carol Nichols 合著的《Rust 编程语言》(No Starch Press, 2018) 详细介绍了这个主题，所以我在此不再赘述基本内容。但是，当您编写这种性质的更复杂类型时，您应该注意这些类型和生存期之间的交互有两个微妙之处。

首先，如果你的类型也实现了 `Drop`，那么丢弃你的类型也算作使用你的类型的任何生存期或类型的泛型。 基本上，当你的类型的一个实例被析构时，借用检查器将检查在析构它之前使用你的类型的任何泛型生存期是否仍然合法。这是必要的，以防你的析构代码确实使用了任何这些引用。如果你的类型没有实现 `Drop`，析构这个类型就不算是使用，用户只要不再使用你的类型，就可以自由地忽略存储在你的类型中的任何引用，就像我们在清单 1-7 中看到的那样。我们将在第 9 章中更多地讨论这些关于析构的规则。

其次，虽然一个类型可以存在多个泛型生存期，但经常这样做只会使你的类型特征变得不必要的复杂。通常情况下，一个类型只使用一个泛型生存期就可以了，编译器会将插入到你的类型中的任何引用的生存期中较短的一个作为这个生存期。只有当你有一个包含多个引用的类型，并且它的方法返回的引用应该只与其中一个引用的生存期相联系时，你才应该真正使用多个泛型生存期参数。

考虑清单 1-10 中的类型，它为您提供了一个迭代器，迭代器将遍历由特定的其他字符串分隔的字符串部分。

```
struct StrSplit<'s, 'p> {
    delimiter: &'p str,
    document: &'s str,
}
impl<'s, 'p> Iterator for StrSplit<'s, 'p> {
    type Output = &'s str;
    fn next(&self) -> Option<Self::Output> {
        todo!()
    }
}
fn str_before(s: &str, c: char) -> Option<&str> {
    StrSplit { document: s, delimiter: &c.to_string() }.next()
}

// 清单 1-10： 一个需要多个泛型生存期的类型
```

当你构造这个类型时，你必须给出 `delimiter` 和要搜索的 `document` ，这两个都是对字符串值的引用。 当你要求下一个字符串时，你会得到一个对 `document` 的引用。考虑一下如果你在这个类型中使用一个单一的生存期会发生什么。迭代器产生的值将与 `document` 的生存期和分隔符相联系。这将使 `str_before` 无法编写：返回类型将有一个与函数本地变量相关的生存期-- `to_string` 产生的 `String`--借用检查器将拒绝该代码。

#### 生存期型变

型变 (Variance) 是程序员经常接触到的一个概念，但很少知道它的名字，因为它大多是看不见的。型变描述了什么类型是其他类型的子类型，以及什么时候可以用子类型代替父类型（反之亦然）。 广义上讲，如果一个类型 `A` 至少和 `B` 一样有用，那么它就是另一个类型 `B` 的子类型。在 Java 中，如果 `Turtle` 是 `Animal` 的子类型，你可以把 `Turtle` 传给接受 `Animal` 的函数，或者在 Rust 中，你可以把一个 `&'static str` 传给接受 `&'a str` 的函数，这就是型变。

虽然型变通常隐藏在视线之外，但它经常出现，我们需要对它有一个工作上的了解。乌龟是动物的一个子类型，因为乌龟比某些未指定的动物更 "有用"--乌龟可以做任何动物能做的事，而且可能更多。同样，`'static` 是 `'a` 的一个子类型，因为 `'static` 的寿命至少与任何 `'a` 一样长，所以更有用。或者，更一般地说，如果 `'b:'a`（`'b` 比 `'a` 长寿），那么 `'b` 就是 `'a` 的一个子类型。这显然不是正式的定义，但是它已经足够接近实际用途了。

所有类型都有一个型变，它定义了哪些其他类似的类型可以用于该类型的位置。有三种型变：协变（covariant）、不变（invariant）和逆变（contravariant）。如果你可以只使用一个子类型来代替该类型，那么该类型就是协变的。例如，如果一个变量是 `&'a T` 类型，你可以给它提供一个 `&'static T` 类型的值，因为 `&'a T` 在 `'a` 上是协变的。`&'a T` 在 `T` 上也是协变的，所以你可以把一个 `&Vec<&'static str>` 传递给一个接受 `&Vec<&'a str>` 的函数。

有些类型是不变的，这意味着你必须准确提供给定的类型。`&mut T` 就是一个例子--如果一个函数接受一个 `&mut Vec<&'a str>`，你不能把一个 `&mut Vec<&'static str>` 传给它。也就是说，`&mut T` 在 `T` 上是不变的。如果你可以，函数可以在 `Vec`中放入一个短暂的字符串，然后调用者会继续使用它，认为它是一个 `Vec<&'static str>`，从而认为包含的字符串是 `'static` ！任何提供可变性的类型一般都是不变的，原因也是如此--例如，`Cell<T>` 在 `T` 上是不变的。

最后一类，逆变，出现在函数参数上。如果函数类型可以接受其参数不那么有用，那么它们就会更有用。如果你将参数类型本身的型变与它们作为函数参数时的型变进行对比，这一点就更清楚了：

```
let x: &'static str; // 更有用，活的更长
let x: &'a str; // 不太有用，活得更短
fn take_func1(&'static str) // 更严格，所以不那么有用
fn take_func2(&'a str) // 不太严格，所以更有用
```

这种翻转的关系表明，`Fn(T)` 在 `T`上是逆变的。

那么，当涉及到生存期时，为什么需要学习型变呢？当您考虑通用生存期参数如何与借用检查器交互时，型变就变得很重要了。考虑清单 1-11 所示的类型，它在一个字段中使用多个生存期。

```
struct MutStr<'a, 'b> {
    s: &'a mut &'b str
}
let mut s = "hello";
*MutStr { s: &mut s }.s = "world"; // (1)
println!("{}", s);

// 清单 1-11: 需要多个泛型生存期的类型
```

乍一看，在这里使用两个生存期似乎是不必要的--我们没有需要区分结构中不同部分的借用的方法，就像我们在清单 1-10 中的 `StrSplit` 那样。 但是如果你把这里的两个生存期换成一个 `'a`，代码就不再能被编译了！这就是为什么我们在这里使用了两个生命周期。而这一切都是因为型变。

> 注意：(1) 处的语法可能看起来很奇怪。它相当于定义了一个持有 `MutStr` 的变量 `x`，然后写 `*x.s = "world"`，只是没有变量，所以 `MutStr` 被立即删除了。

在 (1) 处，编译器必须确定生存期参数应该被设置为什么生存期。如果有两个生命期，`'a` 被设置为有待确定的 `s` 的借用生存期，`'b` 被设置为 `'static`，因为那是提供的字符串 "hello" 的生命期。如果只有一个生命周期 `'a` ，编译器推断该生命周期必须是 `'static`。

当我们后来试图通过共享引用访问字符串引用 `s` 来打印它时，编译器试图缩短 `MutStr` 使用的 `s` 的可变借用，以允许 `s` 的共享借用。

在双生存期的情况下，`'a` 只是在 `println!` 之前结束，`'b` 保持不变。另一方面，在单生存期的情况下，我们遇到了问题。编译器想缩短 `s` 的借用，但要做到这一点，它也必须缩短 `str` 的借用。虽然 `&'static str` 一般来说可以缩短为任何 `&'a str` （ `&'a T` 在 `'a` 中是协变的），但这里它在 `&mut T` 后面，而 `&mut T` 在 `T` 中是不变量的。不变要求相关类型永远不会被子类型或父类型取代，所以编译器缩短借用的尝试失败了，它报告说该清单仍然是可变的借用。哎哟！

由于型变带来的灵活性的降低，你想确保你的类型在尽可能多的泛型参数上保持协变（或在适当情况下保持逆变）。如果这需要引入额外的生命期参数，你需要仔细权衡增加一个参数的认知成本和型变的人机工程成本。

## 总结

本章的目的是建立一个坚实的、共享的基础，我们可以在接下来的章节中建立这个基础。到现在，我希望你觉得你已经牢牢掌握了 Rust 的内存和所有权模型，那些你可能从借用检查器中得到的错误似乎不那么神秘了。你可能已经知道了我们在这里所涉及的零星内容，但希望这一章能给你一个更全面的印象，让你知道这一切是如何结合起来的。在下一章中，我们将为类型做一些类似的事情。我们将讨论类型是如何在内存中表示的，看看泛型和特质（trait）是如何产生运行代码的，并看看 Rust 为更高级的用例提供的一些特殊类型和特质结构。

#  第二章 类型

现在基础知识已经讲完了，我们来看看 Rust 的类型系统。我们将跳过《Rust 编程语言》中涉及的基础知识，转而深入研究不同类型在内存中的布局、特质和特质约束的来龙去脉、存在性类型以及跨箱体边界使用类型的规则。

## 内存中的类型

每个 Rust 值都有一个类型。在 Rust 中，类型有很多作用，我们将在本章中看到，但它们最基本的作用之一是告诉你如何解释内存的位。例如，`0b10111101`（用十六进制符号写成 0xBD）的比特序列本身并不意味着什么，直到你给它指定一个类型。 当解释为 `u8` 类型时，这个比特序列就是数字 `189`。当在 `i8` 类型下解释时，它是`-67`。当你定义自己的类型时，编译器的工作是确定定义类型的每个部分在该类型的内存表示中的位置。你的结构体的每个字段在比特序列中出现在哪里？你的枚举的判别式存储在哪里？当你开始编写更高级的 Rust 代码时，了解这个过程是很重要的，因为这些细节会影响你的代码的正确性和性能。

### 对齐

在我们讨论如何确定一个类型的内存表示之前，我们首先需要讨论对齐的概念，它决定了一个类型的字节可以存储在哪里。一旦一个类型的表示被确定，你可能会认为你可以在任何一个任意的内存位置，把存储在那里的字节解释为该类型。虽然在理论上是这样的，但在实践中，硬件也限制了一个特定类型的位置。这方面最明显的例子是，指针指向字节 (bytes)，而不是比特 (bits)。如果你把一个 `T` 类型的值放在计算机内存的第 4 位开始，你将没有办法参考它的位置；你可以创建一个指针，只指向字节 0 或字节 1（第 8 位）。由于这个原因，所有的值，无论其类型如何，都必须从一个字节边界开始。我们说，所有的值都必须至少是字节对齐的--它们必须被放在一个 8 位 (bits) 的倍数的地址上。

有些数值有更严格的对齐规则，而不仅仅是按字节对齐。在 CPU 和内存系统中，内存经常以大于一个字节的块进行访问。例如，在一个 64 位的 CPU 上，大多数数值都是以 8 个字节（64 位）为单位进行访问的，每个操作都是从一个 8 字节对齐的地址开始。这被称为 CPU 的字大小。然后，CPU 使用一些聪明的方法来处理较小的值，或跨越这些块边界的值的读写。

在可能的情况下，你要确保硬件能够以其 "原生" 对齐方式运行。要知道为什么，考虑一下如果你试图读取一个从 8 字节块中间开始的 `i64`（也就是说，它的指针不是 8 字节对齐的）会发生什么。硬件将不得不进行两次读取--一次是从第一块的后半部分读取 `i64` 的开始，另一次是从第二块的前半部分读取 `i64` 的其余部分，然后将结果拼接在一起。这不是很有效率。由于该操作分散在对底层内存的多次访问中，如果你正在读取的内存被不同的线程同时写入，你也可能会得到奇怪的结果。你可能会在其他线程的写操作发生之前读到前 4 个字节，而在之后读到后 4 个字节，从而导致一个损坏的值。

对未对齐的数据进行的操作被称为错位访问，会导致糟糕的性能和糟糕的并发性问题。出于这个原因，许多 CPU 操作要求或强烈希望其参数是自然对齐的。一个自然对齐的值是指其对齐方式与它的大小相匹配。因此，例如，对于一个 8 字节的负载，提供的地址需要 8 字节对齐。

由于对齐的访问通常更快，并提供更强的一致性语义，编译器试图尽可能地利用它们。它通过给每个类型一个基于它所包含的类型计算出来的对齐方式来实现这一点。内置值通常是根据其大小来对齐的，所以 `u8` 是字节对齐的，`u16` 是 2 字节对齐的，`u32` 是 4 字节对齐的，`u64` 是 8 字节对齐的。复杂类型--包含其他类型的类型--通常被分配为它们所包含的任何类型的最大对齐方式。例如，一个包含 `u8`、`u16` 和 `u32` 的类型会因为 `u32` 而被 4 字节对齐。

### 布局

既然您了解了对齐，我们就可以研究编译器如何决定类型的内存表示，即布局。默认情况下，您很快就会看到，Rust 编译器对如何布局类型提供了很少的保证，这是理解基本原理的一个很差的起点。幸运的是，Rust 提供了一个 `repr` 属性，您可以将其添加到类型定义中，以请求该类型在内存中的特定表示。最常见的是 `repr(C)`。顾名思义，它布局类型的方式与 C 或 C++ 编译器布局相同类型的方式兼容。这对于编写使用外部函数接口（我们将在第 11 章中讨论）与其他语言进行接口的 Rust 代码很有帮助，因为 Rust 将生成与其他语言编译器的期望相匹配的布局。由于 C 布局是可预测的，不受更改的影响，因此 `repr(C)` 在不安全的上下文中也很有用，如果您正在使用到类型的原始指针，或者您需要在两个具有相同字段的不同类型之间进行强制转换。当然，这对于我们开始布局算法的第一步来说是完美的。

> 注意：另一个有用的表示是 repr(transparent)，它只能用于具有单个字段的类型，它保证了外部类型的布局与内部类型的布局完全相同。这在与 newtype 模式结合使用时很方便，在 newtype 模式中，您可能想对某个结构 A 和结构 NewA(A) 的内存表示进行操作，就好像它们是相同的一样。如果没有 repr(transparent)，Rust 编译器就不能保证它们拥有相同的布局。

那么，让我们看看编译器会如何用 `repr(C)` 来布局一个特定的类型：清单 2-1 中的 `Foo` 类型。你认为编译器会如何在内存中布局这个类型？

```
#[repr(C)]
struct Foo {
    tiny: bool,
    normal: u32,
    small: u8,
    long: u64,
    short: u16,
}

// 清单 2-1: 对齐影响布局。
```

首先，编译器会看到 `tiny` 字段，它的逻辑大小是 1 位 (true 或 false)。但由于 CPU 和内存以字节为单位进行操作，因此在内存表示中，`tiny` 是 1 个字节。接下来，`normal` 是一个 4 字节类型，所以我们希望它是 4 字节对齐的。但是即使 `Foo` 是对齐的，我们分配给 `tiny` 的 1 个字节将会使 `normal` 错过它的对齐。为了纠正这个问题，编译器插入 3 个字节的填充字节，这些字节的不确定值在用户代码中被忽略，并插入到内存中 `tiny` 和 `normal` 之间的表示中。没有值进入填充，但它确实占用空间。

对于下一个字段 `small`，对齐方式很简单：它是一个 1 字节的值，当前在结构中的字节偏移量是 1+3+4=8。 这已经是字节对齐的，所以 `small` 可以紧随普通字段。但对于 `long`，我们又遇到了一个问题。我们现在是 1+3+4+1=9 字节进入 `Foo`。如果 `Foo`是对齐的，那么 `long` 就不是我们想要的 8 字节对齐，所以我们必须再插入 7 字节的填充来使 `long` 再次对齐。这也方便了我们确保最后一个字段 `short` 所需的 2 字节对齐，使总数达到 26 字节。现在我们已经浏览了所有的字段，我们还需要确定 `Foo` 本身的对齐方式。这里的规则是使用 `Foo` 任何一个字段的最大对齐方式，由于 `long` 的原因，它将是 8 字节。因此，为了确保 `Foo`在放入数组时保持对齐，编译器添加了最后 6 个字节的填充，使 `Foo` 的大小是其 32 字节对齐的倍数。

现在我们准备摆脱 C 语言的传统，考虑一下如果我们不使用清单 2-1 中的 `repr(C)`，布局会发生什么变化。C 表示法的主要限制之一是它要求我们以原始结构定义中的相同顺序放置所有字段。默认的 Rust 表示法 `repr(Rust)` 消除了这一限制，以及其他一些较小的限制，例如对碰巧有相同字段的类型进行确定的字段排序。也就是说，在使用默认的 Rust 布局时，即使两个不同的类型共享所有相同的字段、相同的类型、相同的顺序，也不能保证它们的布局是一样的。

由于我们现在可以对字段进行重新排序，我们可以按照大小递减的顺序来放置它们。这意味着我们不再需要 `Foo` 字段之间的填充；字段本身被用来实现必要的对齐！`Foo` 现在只是其字段的大小：只有 16 个字节。这就是为什么 Rust 默认情况下不对一个类型在内存中的布局做很多保证的原因之一：通过给编译器更多的余地来重新排列，我们可以产生更有效的代码。

事实证明，还有第三种方法来布局一个类型，那就是告诉编译器，我们不希望在字段之间有任何填充。这样做，我们就表示我们愿意接受使用错位访问的性能冲击。最常见的使用情况是，当每一个额外的字节的内存的影响是可以感觉到的，比如你有很多类型的实例，如果你有非常有限的内存，或者如果你通过一个低带宽的媒介（如网络连接）发送内存中的表示。为了选择这种行为，你可以用 `#[repr(packed)]` 来注释你的类型。请记住，这可能会导致更慢的代码，在极端情况下，如果你试图执行 CPU 只支持对齐参数的操作，这可能会导致你的程序崩溃。

有时，你想给一个特定的字段或类型一个比它技术上要求的更大的对齐方式。你可以使用属性 `#[repr(align(n))]` 来做到这一点。这方面的一个常见的用例是确保在内存中连续存储的不同数值（比如在一个数组中）最终出现在 CPU 的不同缓存行中。这样，你就可以避免错误的共享，因为错误的共享会导致并发程序的巨大性能下降。当两个不同的 CPU 访问不同的值，而这些值恰好共享一个缓存线时，就会发生虚假共享；虽然理论上它们可以并行操作，但它们最终都会争相更新缓存中的同一个条目。我们将在第 10 章中更详细地讨论并发性问题。

### 复合类型

你可能对编译器如何在内存中表示其他 Rust 类型感到好奇。这里有一个快速参考：

**元组** 表示为与元组值相同类型的字段，顺序相同。 **数组** 表示为所含类型的连续序列，元素之间没有填充物。 **联合** 布局是为每个变体独立选择的。 对齐是所有变体的最大值。 **枚举** 与联合相同，但有一个额外的隐藏共享字段，存储枚举变体判别符。判别值是代码用来确定一个给定值持有哪一个枚举变体的值。判别字段的大小取决于变体的数量。

### 动态大小的类型和宽指针

你可能在 Rust 文档的各种奇怪的角落和错误信息中遇到过 `Sized` 这个标记性特质。通常情况下，它的出现是因为编译器希望你提供一个 `Sized` 的类型，但你（显然）没有。Rust 中的大多数类型都自动实现了 `Sized`，也就是说，它们有一个在编译时就知道的大小，但有两种常见的类型却没有：Trait 对象和切片 (slices)。例如，如果你有一个 `dyn Iterator` 或者一个 `[u8]`，这些都没有一个明确的大小。它们的大小取决于一些只有在程序运行时才知道的信息，而不是在编译时，这就是为什么它们被称为动态大小的类型（DSTs）。没有人提前知道你的函数收到的 `dyn Iterator` 是这个 200 字节的结构还是那个 8 字节的结构。这就出现了一个问题：编译器往往必须知道某样东西的大小，以便产生有效的代码，例如为一个类型为（`i32`,`dyn Iterator`, `[u8]`, `i32`）的元组分配多少空间，或者如果你的代码试图访问第四个字段，应该使用什么偏移。但是如果类型不是 `Sized`，这些信息就无法使用。

编译器几乎在任何地方都要求类型是大小适中的。结构字段、函数参数、返回值、变量类型和数组类型都必须是 `Sized` 的。这个限制是如此的普遍，以至于你写的每一个类型绑定都包括`T：Sized`，除非你明确地用 `T：?Sized`（? 的意思是 "可能不是"）来选择不使用它。但如果你有一个 DST 并想用它做一些事情，比如你真的想让你的函数接受一个 trait 对象或一个 slice 作为参数，这就很无助了。

弥合非固定大小类型和固定大小类型之间的差距的方法是将非固定大小类型放在宽指针（也被称为胖指针）后面。一个宽指针就像一个正常的指针，但它包括一个额外的字大小的字段，它提供了编译器需要的关于该指针的额外信息，以生成合理的代码来处理该指针。当你获取一个对 DST 的引用时，编译器会自动为你构造一个宽指针。对于一个切片，额外的信息只是切片的长度。对于 trait 对象来说，我们稍后会讨论这个问题。最重要的是，这个宽指针是有尺寸的。具体来说，它是 `usize`（目标平台上一个字的大小）的两倍：一个 `usize` 用于保存指针，一个 `usize` 用于保存 "完成 "类型所需的额外信息。

> 注：Box 和 Arc 也支持存储宽指针，这就是为什么它们都支持 `T：?Sized`。

## Trait 和 Trait 约束

特质是 Rust 类型系统的一个关键部分--它们是一种胶水，允许类型之间相互操作，尽管它们在定义时并不了解对方的情况。Rust 编程语言对如何定义和使用特质做了很好的介绍，所以我在这里就不做介绍了。取而代之的是，我们要看看 traits 的一些技术方面：它们是如何实现的，你必须遵守的限制，以及 traits 的一些更深奥的用途。

### 编译和分发

到目前为止，你可能已经在 Rust 中写了相当数量的泛型代码。你已经在类型和方法上使用了泛型类型参数，甚至可能在这里和那里使用了一些 trait 约束。但是你有没有想过，当你编译泛型代码时，它究竟会发生什么，或者当你在 `dyn Trait` 上调用一个 trait 方法时，会发生什么？

当你写一个在 `T` 上泛型的类型或函数时，你实际上是在告诉编译器为每个类型 `T` 制作一个该类型或函数的副本。当你构造一个 `Vec<i32>` 或 `HashMap<String, bool>` 时，编译器基本上是复制粘贴泛型类型和它的所有实现块，并将每个泛型参数的所有实例替换为你提供的具体类型。它制作了一个 `Vec` 类型的完整副本，每个 `T` 都被替换为 `i32`，而 `HashMap` 类型的完整副本，每个 `K` 都被替换为 `String`，每个 `V` 都被替换为 bool。

> 注意：在现实中，编译器实际上并没有进行完全的复制。它只复制你使用的部分代码，所以如果你从未在 `Vec<i32>` 上调用 `find`，`find` 的代码就不会被复制和编译。

这一点也适用于泛型函数。考虑清单 2-2 中的代码，它显示了一个泛型方法。

```
impl String {
    pub fn contains(&self, p: impl Pattern) -> bool {
        p.is_contained_in(self)
    }
}

// 清单 2-2：使用静态分发的泛型方法
```

这个方法的副本是为每个不同的模式类型制作的（记得 `impl Trait` 是 `<T: Trait>` 的简写）。我们需要为每个 `impl Pattern`类型提供一个不同的函数体副本，因为我们需要知道 `is_contained_in` 函数的地址来调用它。CPU 需要被告知跳转到哪里并继续执行。对于任何给定的模式，编译器知道该地址是该模式类型实现该 trait 方法的地方的地址。但是没有一个地址可以用于任何类型，所以我们需要为每个类型准备一个副本，每个副本都有自己的地址可以跳转。 这被称为静态分发，因为对于任何给定的方法副本，我们 "分发到" 的地址是静态已知的。

> 注意：你可能已经注意到，"静态" 这个词在这里有点超载。静态通常是指任何在编译时已知的东西，或者可以被当作已知的东西来对待，因为它可以被写入静态内存，正如我们在第 1 章中讨论的。

这个从一个泛型到许多非泛型的过程被称为单态化，这也是泛型 Rust 代码通常和非泛型代码表现一样好的部分原因。 当编译器开始优化你的代码时，就好像根本没有泛型的存在一样！每个实例都被单独优化，并使用所有已知的类型。每个实例都是单独优化的，并且所有的类型都是已知的。因此，代码的效率就像直接调用传入的模式的 `is_contained_in` 方法一样，没有任何特质存在。编译器对所涉及的类型有充分的了解，如果愿意，甚至可以内联 `is_contained_in` 的实现。

单态化也是有代价的：所有这些类型的实例化都需要单独编译，如果编译器不能将它们优化掉，就会增加编译时间。每个单态化的函数也会产生自己的机器代码块，这可能会使你的程序变得更大。而且，由于泛型方法的不同实例之间不共享指令，CPU 的指令缓存也是无效的，因为它现在需要保存有效相同指令的多个副本。

> 非泛型内部函数
>
> 通常情况下，泛型方法中的大部分代码是不依赖于类型的。例如，考虑一下 `HashMap::insert` 的实现。计算所提供键的哈希值的代码取决于映射的键类型，但是遍历映射的桶以找到插入点的代码可能不需要。在这种情况下，跨单一化共享方法的非通用部分生成的机器码会更有效，并且只在实际需要的地方生成不同的副本。
>
> 在这种情况下，你可以使用一种模式，即在执行共享操作的泛型方法中声明一个非泛型的辅助函数。这样，编译器就只留下与类型相关的代码来为你复制粘贴，同时允许辅助函数被共享。
>
> 把函数变成内部函数还有一个好处，就是你不会用一个单一目的的函数来污染你的模块。你可以在方法之外声明这样一个辅助函数；只是要注意不要让它成为泛型植入块下的方法，因为那样它仍然会被单态化。

静态分发的替代方法是动态分发，它使代码能够在不知道是什么类型的情况下调用一个泛型类型的 trait 方法。我在前面说过，我们需要清单 2-2 中方法的多个实例的原因是，否则你的程序就不知道要跳转到什么地址，以便在给定的模式上调用特质方法 `is_contained_in`。那么，通过动态分发，调用者会简单地告诉你。如果你用 `&dyn Pattern` 代替 `impl Pattern`，你就告诉调用者他们必须为这个参数提供两个信息：模式的地址和 `is_contained_in` 方法的地址。实际上，调用者给了我们一个指针，指向一个叫做虚拟方法表（vtable）的内存块，这个虚拟方法表保存了有关类型的所有 trait 方法的实现地址，其中一个就是 `is_contained_in`。当方法中的代码想要调用所提供的模式的特质方法时，它会在 `vtable` 中查找该模式的 `is_contained_in`的实现地址，然后调用该地址的函数。这使得我们可以使用相同的函数体，无论调用者想使用什么类型。

> 注意：每个 `vtable` 都包含了关于具体类型的布局和对齐方式的信息，因为这些信息在使用一个类型时总是需要的。如果你想看一个显式 `vtable` 的例子，看看 `std::task::RawWakerVTable` 类型。

你会注意到，当我们选择使用 `dyn` 关键字进行动态分发时，我们必须在它的前面放一个 `&`。原因是我们在编译时不再知道调用者传入的模式类型的大小，所以我们不知道要为它预留多少空间。换句话说，`dyn Trait` 是 `!Sized`，其中的 `!` 表示不。为了使它有大小，以便我们可以把它作为一个参数，我们把它放在一个指针（我们知道它的大小）后面。由于我们还需要传递方法地址表，这个指针变成了一个广义的指针，其中额外的字是指向 `vtable` 的指针。你可以使用任何能够容纳宽指针的类型进行动态分发，比如 `&mut`、 `Box` 和 `Arc`。清单 2-3 显示了清单 2-2 的动态分发等价物。

```
impl String {
    pub fn contains(&self, p: &dyn Pattern) -> bool {
        p.is_contained_in(&*self)
    }
}

// 清单 2-3: 使用动态分发的泛型方法
```

实现特质的类型和其 `vtable` 的组合被称为特质对象。大多数特质可以变成特质对象，但不是全部。例如，`Clone trait`，其 `clone` 方法返回 自身，不能被转化为特质对象。如果我们接受一个 `dyn Clone trait` 对象，然后对它调用 `clone`，编译器将不知道要返回什么类型。或者，考虑一下标准库中的 `Extend trait`，它有一个方法 `extend`，在所提供的迭代器的类型上是通用的（所以它可能有很多实例）。如果你要调用一个接受动态 `Extend` 的方法，那么就没有一个单一的地址可以放在 trait 对象的 `vtable` 中；对于 `extend` 可能被调用的每种类型，都必须有一个条目。这些都是特性的例子，它们不是对象安全的，因此不能被变成特性对象。为了实现对象安全，特质的任何方法都不能是泛型的或使用`Self` 类型。此外，特质不能有任何静态方法（也就是说，其第一个参数不解引用到 `Self`），因为不可能知道要调用哪个方法的实例。例如，不清楚 `FromIterator::from_iter(&[0])` 应该执行什么代码。

在阅读关于特质对象的文章时，你可能会看到提到特质绑定 `Self: Sized`。这样的约束意味着 `Self` 不会通过 trait 对象被使用（因为它将是 `!Sized`）。你可以把这个约束放在特质上，要求特质永远不使用动态分发，或者你可以把它放在一个特定的方法上，使该方法在通过特质对象访问特质时不可用。当检查一个特质是否是对象安全的时候，具有 `where Self: Sized` 绑定的方法被豁免。

动态分发可以缩短编译时间，因为它不再需要编译多个类型和方法的副本，而且可以提高 CPU 指令缓存的效率。然而，它也阻止了编译器对所使用的特定类型进行优化。有了动态分发，编译器对清单 2-2 中的 `find` 所能做的就是通过 `vtable` 插入对函数的调用--它不能再执行任何额外的优化，因为它不知道在这个函数调用的另一边会有什么代码。 此外，对 trait 对象的每个方法调用都需要在 `vtable` 中进行查找，这比直接调用方法增加了少量的开销。

当你要在静态分发和动态分发之间做出选择时，很少有明确的正确答案。不过，广义上讲，你想在你的库中使用静态分发，在你的二进制文件中使用动态分发。在库中，你想让你的用户来决定哪种分发最适合他们，因为你不知道他们的需求是什么。如果你使用动态分发，他们也会被迫这样做，而如果你使用静态分发，他们可以选择是否使用动态分发。另一方面，在二进制文件中，你正在编写最终的代码，所以除了你正在编写的代码的需求外，没有其他需求需要考虑。 动态分发通常允许你编写更干净的代码，省去泛型参数，并能更快地编译，所有这些都是以（通常）边际性能为代价，所以它通常是二进制文件的更好选择。

### 泛型 Traits

Rust 特质可以通过两种方式之一称为泛型：使用泛型类型参数，如 `trait Foo<T>`，或者使用关联类型，如 `trait Foo { type Bar; }`。这两者之间的区别并不明显，但幸运的是，经验法则非常简单：如果你希望一个给定的类型只有一个特质的实现，那么就使用关联类型，否则就使用通用类型参数。

这样做的理由是，关联类型通常更容易操作，但不允许多种实现。所以，更简单地说，我们的建议是，只要你能使用关联类型，就使用关联类型。

有了泛型特质，用户必须始终指定所有的泛型参数，并重复这些参数的任何约束。这很快就会变得混乱和难以维护。如果你给一个特质增加了一个泛型参数，该特质的所有用户也必须更新以反映这一变化。而且，由于一个特质的多个实现可能存在于一个给定的类型中，编译器可能很难确定你想使用特质的哪个实例，从而导致像 `FromIterator::<u32>::from_iter` 这样可怕的歧义函数调用。 但好处是，你可以为同一类型多次实现特质--例如，你可以针对你的类型的多个右手边类型实现 `PartialEq`，或者你可以同时实现 `FromIterator<T>`和 `FromIterator<&T> where T: Clone`，正是因为通用特质所提供的灵活性。

另一方面，对于关联类型，编译器只需要知道实现特质的类型，而所有的关联类型都是如此（因为只有一个实现）。这意味着约束可以全部存在于特质本身，不需要在使用时重复。反过来，这允许特质在不影响用户的情况下增加更多的关联类型。因为类型决定了特质的所有关联类型，所以你永远不需要用上一段中显示的统一函数调用语法来消除歧义。然而，你不能针对多个目标类型实现 `Deref`，也不能用多个不同的 `Item` 类型实现 `Iterator`。

### 连贯性和孤儿规则

Rust 有一些相当严格的规则，规定你可以在哪里实现特性，以及你可以在哪些类型上实现它们。这些规则的存在是为了保护一致性属性：对于任何给定的类型和方法，只有一个正确的选择，那就是对该类型使用该方法的实现。为了理解这一点的重要性，考虑一下如果我可以为标准库中的 `bool` 类型编写自己的 `Display` 特性的实现会发生什么。现在，对于任何试图打印一个 `bool` 值并包括我的 `crate` 的代码，编译器将不知道是选择我写的实现还是标准库的实现。这两种选择都不正确，也不比其他选择好，而且编译器显然不能随机选择。如果完全不涉及标准库，但我们有两个相互依赖的包 (crate)，而且它们都实现了某个共享类型的特质，也会出现同样的问题。连贯性属性保证了编译器永远不会在这些情况下结束，也永远不需要做出这些选择：总会有一个明显的选择。

维护一致性的一个简单方法是确保只有定义特质的包 (crate) 可以编写该特质的实现；如果没有其他人可以实现该特质，那么其他地方就不能有冲突的实现。然而，这在实践中限制性太强，而且基本上会使特质失去作用，因为没有办法为你自己的类型实现诸如 `std::fmt::Debug` 和 `serde::Serialize` 这样的特质，除非你把自己的类型包含在定义框中。相反的极端做法是，你可以只为你自己的类型实现特性，这解决了这个问题，但却带来了另一个问题：一个定义了特性的包现在不能为标准库或其他流行的包中的类型提供该特性的实现 理想情况下，我们希望找到一些规则来平衡下游包为自己的类型实现上游特质的愿望和上游包能够在不破坏下游代码的情况下增加自己的特质实现的愿望。

> 注意：上游指的是你的代码所依赖的东西，下游指的是依赖你的代码的东西。 通常，这些术语是在 crate 依赖关系的直接意义上使用的，但它们也可以用来指代码的权威分叉--如果你做一个 Rust 编译器的分叉，官方 Rust 编译器就是你的 "上游"。

在 Rust 中，建立这种平衡的规则是孤儿规则。 简单地说，孤儿规则说你可以为一个类型实现一个特质，但该特质或类型必须是你的包的本地的。所以，你可以为你自己的类型实现 `Debug`，也可以为 `bool` 实现 `MyNeatTrait`，但你不能为 `bool` 实现 `Debug`。如果你尝试，你的代码将无法编译，而且编译器会告诉你有冲突的实现。

这让你走得很远；它允许你为第三方类型实现你自己的特质，并为你自己的类型实现第三方特质。然而，孤儿规则并不是故事的结束。它还有一些额外的影响、注意事项和例外情况，你应该注意一下。

#### 覆盖实现（Blanket Implementations）

孤规则允许你在一系列类型上实现特质，代码如 `impl<T> MyTrait for T where T:`，等等。这是一个覆盖的实现，它不局限于一个特定的类型，而是适用于广泛的类型。只有定义了一个 `trait` 的包被允许编写一个覆盖实现，并且添加一个覆盖实现到一个已经存在的 `trait` 被认为是一个破坏性的改变。如果不是的话，下游包含 `impl MyTrait for Foo` 的包可能会突然停止编译，因为你更新了定义 `MyTrait` 的包，出现了一个关于冲突实现的错误。

#### 基本类型

有些类型是如此重要，以至于有必要允许任何人在其上实现特性，即使这似乎违反了孤儿规则。这些类型被标记为 `#[fundamental]` 属性，目前包括 `&`, `&mut`, 和 `Box`。为了孤儿规则的目的，基本类型可能不存在--它们在孤儿规则被检查之前就被有效地删除了，以便允许你，例如，为 `&MyType` 实现 `IntoIterator`。如果只有孤儿规则，这个实现将不被允许，因为它为一个外来类型实现了一个外来特性-- `IntoIterator` 和 `&` 都来自标准库。在一个基本类型上添加一个覆盖的实现也被认为是一个破坏性的改变。

#### 覆盖实现 (Covered Implementations)

在一些有限的情况下，我们想允许为一个外来类型实现一个外来特性，而孤儿规则通常不允许这样做。最简单的例子是当你想编写类似 `impl From<MyType> for Vec<i32>` 的东西。在这里，`From` 特质是外来的，`Vec` 类型也是，但没有违反一致性的危险。这是因为冲突的实现只能通过标准库中的覆盖实现来添加（标准库不能以其他方式命名 `MyType`），这无论如何是一个破坏性的改变。

为了允许这些类型的实现，孤规则包含了一个很小的豁免，允许在非常特定的一组环境下为外部类型实现外部特质。具体来说，给定 `impl<P1..=Pn> ForeignTrait<T1..=Tn> for T0` 是允许的，只有当至少一个 `Ti` 是本地类型，并且在第一个这样的 `Ti` 之前没有 `T` 是泛型类型 `P1..=Pn`。泛型类型参数 (Ps) 允许出现在 `T0..Ti` 只要它们被某种中间类型所覆盖。如果 `T` 作为其他类型的类型参数出现（比如 `Vec<T>`)，则会覆盖它，但如果它独立存在（只是 `T`)，或者只是出现在基本类型（比如 `&T` ) 后面，则不会覆盖它。因此，清单 2-4 中的所有实现都是有效的。

```
impl<T> From<T> for MyType
impl<T> From<T> for MyType<T>
impl<T> From<MyType> for Vec<T>
impl<T> ForeignTrait<MyType, T> for Vec<T>

// 清单 2-4: 外部类型的外部特质的有效实现
```

但是，清单 2-5 中的实现是无效的。

```
impl<T> ForeignTrait for T
impl<T> From<T> for T
impl<T> From<Vec<T>> for T
impl<T> From<MyType<T>> for T
impl<T> From<T> for Vec<T>
impl<T> ForeignTrait<T, MyType> for Vec<T>

// 清单 2-5: 外部类型的外部特质的无效实现
```

对孤儿规则的这种放宽使得当你为现有特质添加新的实现时构成破坏性改变的规则变得复杂。特别是，为现有特质添加新的实现，只有当它至少包含一个新的本地类型，并且这个新的本地类型满足前面描述的豁免规则时，才是非破坏性的。添加任何其他新的实现都是一种破坏性的改变。

> 注意：`impl<T> ForeignTrait<LocalType, T> for ForeignType` 是有效的，但是 `impl<T> ForeignTrait<T, LocalType> for ForeignType` 是无效的！这看起来很随意，但是如果没有这个规则，你可以为写 `impl<T> ForeignTrait<T, LocalType> for ForeignType`，而另一个包可以写 `impl<T> ForeignTrait<TheirType, T> for ForeignType`，只有当这两个包被放在一起时才会产生冲突。 孤儿规则没有完全禁止这种模式，而是要求你的本地类型在类型参数之前，这打破了联系，确保如果两个包在孤立情况下坚持一致性，它们在合并时也坚持一致性。

### Trait 约束

标准库中有很多特质约束，无论是 `HashMap` 中的键必须实现 `Hash + Eq`，还是 `Thread::Spawn` 的函数必须是 `FnOnce + Send + 'static`。当你自己写泛型代码时，几乎肯定会包括特质约束，因为否则你的代码就不能对它所泛型的类型做什么。当你写出更复杂的泛型实现时，你会发现你也需要从你的特质约束中获得更多的保真度，所以让我们看看实现这一目的的一些方法。

首先，特质约束不一定是 `T: Trait` 的形式，其中 `T` 是你的实现或类型的泛型的一些类型。约束可以是任意的类型限制，甚至不需要包括泛型参数、参数类型或本地类型。你可以写一个 trait 约束，比如说 `where String: Clone`，尽管 `String: Clone` 总是真的，并且不包含本地类型。你也可以写 `where io::Error: From<MyError<T>>`；你的泛型类型参数不需要只出现在左手边。这不仅允许你表达更复杂的约束，而且可以使你避免不必要地重复约束。例如，如果你的方法要构造一个 `HashMap<K, V, S>`，它的键是一些泛型 `T`，它的值是一个 `usize`，与其把约束写成 `where T: Hash + Eq, S: BuildHasher + Default`，你可以写成 `where HashMap<T, usize, S>: FromIterator`。这样就省去了查找你最终使用的方法的确切约束要求，并且更清楚地传达了你的代码的真正要求。正如你所看到的，如果你想调用的底层特质方法的约束很复杂，它也能大大降低你的约束的复杂性。

> DERIVE TRAIT 虽然 `#[derive(Trait)]` 非常方便，但在 trait 约束的上下文中，你应该注意到它经常被实现的一个微妙之处。许多`#[derive(Trait)]` 的扩展被分解为 `impl Trait for Foo<T> where T: Trait`。这通常是你想要的，但并不总是如此。例如，考虑一下如果我们试图以这种方式为 `Foo<T>` 派生 `Clone`，而 `Foo` 包含一个 `Arc<T>`，会发生什么。不管 `T`是否实现了 `Clone`，`Arc` 都实现了 `Clone`，但是由于派生的约束，`Foo` 只有在 `T` 实现了 `Clone` 时才会实现！这通常不是一个太大的问题，但是它确实在不需要的地方增加了一个约束。如果我们把这个类型重命名为 `Shared`，问题可能会变得更清楚一些。想象一下，当编译器告诉他们不能克隆 `Shared<NotClone>`时，拥有 `Shared<NotClone>` 的用户将是多么的困惑啊！在写这篇文章的时候，这就是标准库提供的 `#[derive(Clone)]` 的工作方式，尽管这在将来可能会改变。

有时候，你需要对泛型类型的关联类型进行约束。例如，考虑迭代器方法 `flatten`，它接受一个迭代器，该迭代器生成的项依次实现 `iterator`，并生成这些内部迭代器的项的迭代器。它产生的类型 `Flatten` 是 `I` 上的泛型，这是外部迭代器的类型。`Flatten` 实现 `Iterator`，如果我实现 `Iterator`，我自己产生的项目实现 `IntoIterator`。为了使您能够像这样编写约束，Rust 允许您使用 `type::AssocType` 语法引用类型的关联类型。例如，我们可以使用 `I::Item` 来引用 `I` 的 `Item` 类型。如果一个类型有多个同名的关联类型，比如提供关联类型的 trait 本身就是泛型（因此有很多实现），你可以用语法 `<Type as Trait>::AssocType` 来消除歧义。使用这个方法，你不仅可以为外层迭代器的类型写边界，还可以为该外层迭代器的项目类型写边界。

在广泛使用泛型的代码中，您可能会发现需要编写一个讨论对类型的引用的约束。这通常没有问题，因为您可能还会有一个泛型的生存期参数，可以将其用作这些引用的生存期。然而，在某些情况下，您希望约束说明此引用在任何生命周期实现此 trait。这种类型的约束被称为高阶生存期的 trait 约束，它在与 `Fn` 特质的联系中特别有用。例如，假设你想成为一个泛型函数，它接受一个对 `T` 的引用，并返回一个对 `T` 内部的引用，如果你写 `F: Fn(&T) -> &U`，您需要为这些引用提供一个生存期，但是您真正想说的是任何生存期，只要输出与输入相同。使用高阶的生存期，你可以写 `F: for<'a> Fn(&'a T) -> &'a U` 表示在任何生存期中，这个约束都必须成立。Rust 编译器足够聪明，当你用这样的引用编写 `Fn` 约束时，它会自动添加 `for`，这涵盖了此特性的大部分用例。在编写本文时，这种显式形式很少被需要，因此标准库只在三个地方使用它，但它确实存在，因此值得了解。

为了把所有这些结合起来，考虑清单 2-6 中的代码，它可以用来为任何可以被迭代的类型实现 `Debug`，并且其元素是 `Debug`。

```
impl Debug for AnyIterable
    where for<'a> &'a Self: IntoIterator,
        for<'a> <&'a Self as IntoIterator>::Item: Debug {
    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {
        f.debug_list().entries(self).finish()
    }
}

// 清单 2-6：对任何可迭代的集合来说，Debug 的实现都过于通用。
```

你可以把这个实现复制粘贴到几乎所有的集合类型上，它就会 "正常工作"。当然，你可能想要一个更聪明的调试实现，但这很好地说明了特质约束的力量。

### 标记 Traits

通常，我们使用特质来表示多种类型可以支持的功能；`Hash` 类型可以通过调用 `hash` 进行哈希处理，`Clone` 类型可以通过调用 `clone` 进行克隆，`Debug` 类型可以通过调用 `fmt` 进行格式化。但并不是所有的特质都是这样起作用的。有些特质（称为标记特质）指示的是实现类型的属性。标记特质没有方法或相关的类型，只是用来告诉你某一特定类型可以或不能以某种方式使用。例如，如果一个类型实现了 `Send` 标记特质，那么跨线程边界发送是安全的。如果它没有实现这个标记符特质，发送它就不安全。没有与此行为相关的方法；这只是一个关于类型的事实。在 `std::marker` 模块中，标准库有许多这样的标记，包括 `Send`， `Sync`， `Copy`， `Sized`, 和 `Unpin`。其中大多数（除了`Copy`）也是自动特质；编译器会自动为类型实现它们，除非类型包含没有实现标记特质的内容。

标记特质在 Rust 中有一个重要的作用：它允许你写出捕获语义要求的约束，而这些要求在代码中没有直接表达。在代码中没有调用 `send`，要求一个类型是 `Send`。相反，代码假设给定的类型可以在一个单独的线程中使用，如果没有标记特质，编译器将没有办法检查这个假设。这就需要程序员记住这个假设并仔细阅读代码，我们都知道这不是我们想要依赖的东西。这条路充满了数据竞争、分离故障和其他运行时问题。

与标记特质类似的是标记类型。这些是单元类型（如 `struct MyMarker;`），不持有数据，也没有方法。标记类型对于，嗯，标记一个类型处于一个特定的状态很有用。当你想让用户不可能滥用一个 API 时，它们就会派上用场。例如，考虑一个像 `SshConnection` 这样的类型，它可能已经被验证，也可能还没有被验证。你可以给 `SshConnection` 添加一个通用类型参数，然后创建两个标记类型。未认证的和已认证的。当用户第一次连接时，他们得到 `SshConnection<Unauthenticated>`。在其 `impl`块中，你只提供了一个方法：`connect`。`connect` 方法返回一个 `SshConnection<Authenticated>`，只有在这个 `impl` 块中，你才提供其余的方法来运行命令等。 我们将在第 3 章进一步研究这个模式。

## 存在类型 （Existential Types）

在 Rust 中，你很少需要指定你在函数主体中声明的变量的类型，或者你调用的方法的泛型参数的类型。这是因为类型推断的存在，编译器根据类型出现在代码中的评估结果决定使用什么类型。编译器通常只对变量和闭包的参数（和返回类型）进行类型推断；像函数、类型、特质和特质实现块这样的顶层定义都需要你明确命名所有的类型。 这有几个原因，但主要的原因是，当你至少有一些已知的点来开始推断时，类型推断就容易多了。然而，要完全命名一个类型并不总是容易的，甚至是不可能的。例如，如果你从一个函数中返回一个闭包，或者从一个特质方法中返回一个异步块，它的类型并没有一个你可以在代码中输入的名字。

为了处理这样的情况，Rust 支持存在性（`existential`）类型。 你可能已经看到了存在性类型的作用。所有标记为 `async fn` 或者返回类型为 `impl Trait` 的函数都有一个存在性的返回类型：签名中没有给出返回值的真实类型，只是提示函数返回的某个类型实现了调用者可以依赖的一组特性。更重要的是，调用者只能依赖实现这些特质的返回类型，而不能依赖其他。

> 注意：从技术上讲，调用者只依赖返回类型而不依赖其他，这并不是严格意义上的。编译器也会通过返回位置的 `impl Trait`来传播 `Send` 和 `Sync` 等自动特性。我们将在下一章中进一步研究这个问题。

这种行为就是存在性类型的名称：我们断言存在某种与签名相匹配的具体类型，而我们让编译器去寻找这种类型。编译器通常会通过在函数主体上应用类型推理来找出这个类型。

并非所有 `impl Trait` 的实例都使用存在性类型。如果你在一个函数的参数位置使用 `impl Trait`，它实际上只是该函数的一个未命名的泛型参数的缩写。例如，`fn foo(s: impl ToString)` 大多只是 `fn foo<S: ToString>(s: S)`。当你实现有相关类型的特质时，存在性类型就特别有用了。例如，设想你正在实现 `IntoIterator` trait。它有一个相关的类型 `IntoIter`，持有相关类型可以变成的迭代器的类型。对于存在性类型，你不需要定义一个单独的迭代器类型来用于 `IntoIter`。相反，你可以给出关联类型为 `impl Iterator<Item = Self::Item>`，并且只需在 `fn into_iter(self)` 里面写一个表达式，评估为一个 `Iterator`，比如通过在一些现有的迭代器类型上使用 maps 和 filters。

存在性类型还提供了一个不仅仅是方便的功能：它们允许你进行零成本的类型清除。你可以使用存在类型来隐藏底层的具体类型，而不是仅仅因为它们出现在某个公共签名中就导出辅助类型--迭代器和 future 就是这种常见的例子。 你的接口的用户只能看到相关类型所实现的特质，而具体类型则作为一个实现细节留下。这不仅简化了接口，而且还使你能够随心所欲地改变实现，而不会在将来破坏下游的代码。

## 总结

本章对 Rust 的类型系统进行了全面的回顾。我们既看了编译器如何在内存中表现类型，又看了它如何对类型本身进行推理。这是编写不安全代码、复杂应用接口和异步代码的重要背景材料。 你还会发现，本章中的许多类型推理在你如何设计 Rust 代码接口方面发挥了作用，我们将在下一章介绍。